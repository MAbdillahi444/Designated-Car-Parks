# Testing

## Test Plan
Software engineers differentiate between software faults and software failures in their professional practice. The software fails to execute its intended user functions. Programming errors which could produce system failures are known as faults yet they lack proven instances of failure occurrence. The semantic correctness error in the design of computer programs constitutes a fault in programming. A fault develops into a failure when the computation conditions are fulfilled and the faulty computer program section runs on the CPU. A programming fault has the potential to evolve into software failure if software developers port applications to new compilers translate them between hardware systems or create program extensions.

Testing goals work to build organizational confidence in software quality which leads to a satisfactory defect percentage. Software defect rates that organizations accept vary based on the characteristics of specific software systems. Software testing faces the challenge of having large numbers of product defects alongside even higher possible product configuration levels. Uncommon defects are hard to detect during the testing period. Software testing duration must surpass the anticipated system operating duration because it serves as a baseline for reliability assurance. A project seeking to develop long-lived dependable software faces commercial limitations when testing beyond a standard timeframe unless testing spans a brief amount of time. System verification usually needs a few working days or one week using standard operational start and conclusion protocols yet demands simulations for any lengthier durations.

Testing a software product commonly happens through independent tester groups who operate following development until product shipment occurs to customers. Such practices enable the testing phase to function as a delay compensation method which reduces testing duration. The practice begins testing software at project startup with testing reflecting an unbroken process until project completion.




Software Testing Standard

1. It is impossible to test a program completely.
2. Software testing is a risk-based exercise.
3. Testing cannot show that bugs don't exist.
4. The more bugs you find, the more bugs there are.
5. Not all the bugs you find will be fixed.
6. Product specifications are never final.


Verification and Validation

Software testing operates together with verification and validation (V&V) procedures. The act of testing items including software for their adherence to their specified standards is known as verification. Among verification methods used for testing stands software testing along with reviews inspections and walkthroughs. The validation method checks if the user desired elements align with the original specification.

The product needs verification testing to show whether the program meets its specifications. Our objective is to verify whether we assembled the correct software system according to customer requirements. Does what the customer needs to have?


â€ƒ


**

Test Runs


|**Use-Case ID**| Requirement ID | Test Case | Status |

| **Test case 1**| UCID1 | Ensure the application correctly retrieves and displays car parks based on a valid location search.|Passed|
| T**est case 2** | UCID2 | Confirm that the application appropriately handles an invalid location search. | Passed|
| **Test case 3** | UCID3 | Verify that the application correctly filters car parks by a valid type selection. | Passed |
| **Test case 4** | UCID4 | Verify that selecting a car park displays detailed information| Passed |
| **Test case 5** | UCID5 | Check how quickly the application responds to user interactions, such as searching and filtering.| Passed |
| **Test case 6** | UCID5 | Confirm that the application functions correctly across major web browsers.| Passed |
| **Test case 7** | UCID5 |Assess how well the application operates on different mobile devices.| Passed |




